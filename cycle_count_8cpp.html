<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithmique pour le consensus d’ordres: src/cycleCount.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Algorithmique pour le consensus d’ordres
   </div>
   <div id="projectbrief">Plusieurs méthodes exactes ou approchées pour obtenir un consensus d&#39;ordre. C&#39;est-à-dire, transformer une relation binaire quelconque en une relation d&#39;ordre partiel avec une perte d&#39;information minimisée. Ces algorithmes servent le contexte bio-informatique de la cartographie génétique.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('cycle_count_8cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cycleCount.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &quot;<a class="el" href="eigenvalues_8h_source.html">../header/eigenvalues.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cycle_count_8h_source.html">../header/cycleCount.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cycleCount.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="cycle_count_8cpp__incl.png" border="0" usemap="#asrc_2cycle_count_8cpp" alt=""/></div>
<map name="src_2cycle_count_8cpp" id="asrc_2cycle_count_8cpp">
<area shape="rect" title=" " alt="" coords="201,5,333,32"/>
<area shape="rect" title=" " alt="" coords="5,80,77,107"/>
<area shape="rect" title=" " alt="" coords="101,80,160,107"/>
<area shape="rect" title=" " alt="" coords="184,80,259,107"/>
<area shape="rect" title=" " alt="" coords="283,80,341,107"/>
<area shape="rect" href="eigenvalues_8h.html" title=" " alt="" coords="365,80,520,107"/>
<area shape="rect" href="cycle_count_8h.html" title=" " alt="" coords="544,80,693,107"/>
</map>
</div>
</div>
<p><a href="cycle_count_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6dabfa59d44c075887cbe5466ed7030f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a6dabfa59d44c075887cbe5466ed7030f">EIGEN_MAX_ITERATION</a>&#160;&#160;&#160;10000</td></tr>
<tr class="separator:a6dabfa59d44c075887cbe5466ed7030f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a917f856829fd502d3c445095d53a82ea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a917f856829fd502d3c445095d53a82ea">pathsCount</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, unsigned long length, bool directed)</td></tr>
<tr class="separator:a917f856829fd502d3c445095d53a82ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27cf7494f9faa660df78fbd19af5cb3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#ad27cf7494f9faa660df78fbd19af5cb3">recursiveSubgraphsPaths</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, unsigned long length, std::vector&lt; int &gt; subgraph, std::vector&lt; bool &gt; allowedVertex, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;primes, std::vector&lt; bool &gt; neighbourhood, bool directed)</td></tr>
<tr class="separator:ad27cf7494f9faa660df78fbd19af5cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39473983d87ddb4bb00bf72cc3c49c6d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a39473983d87ddb4bb00bf72cc3c49c6d">primeCountPath</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, unsigned long length, std::vector&lt; int &gt; &amp;subgraph, unsigned long neighboursNumber, std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;primes)</td></tr>
<tr class="separator:a39473983d87ddb4bb00bf72cc3c49c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ca4ca2fc0aa3db96311d853c95c825"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a26ca4ca2fc0aa3db96311d853c95c825">cycleCount</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, unsigned long length, bool directed)</td></tr>
<tr class="separator:a26ca4ca2fc0aa3db96311d853c95c825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84eabb4f4c460f175ec21b366b5efd63"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a84eabb4f4c460f175ec21b366b5efd63">recursiveSubgraphs</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, unsigned long length, std::vector&lt; int &gt; subgraph, std::vector&lt; bool &gt; allowedVertex, std::vector&lt; double &gt; primes, std::vector&lt; bool &gt; neighbourhood, bool directed)</td></tr>
<tr class="separator:a84eabb4f4c460f175ec21b366b5efd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6356a2ac3c7689b35ac0f7b47d7f1b4b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a6356a2ac3c7689b35ac0f7b47d7f1b4b">primeCount</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, unsigned long length, std::vector&lt; int &gt; &amp;subgraph, unsigned long neighboursNumber, std::vector&lt; double &gt; &amp;primes, bool directed)</td></tr>
<tr class="separator:a6356a2ac3c7689b35ac0f7b47d7f1b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2479fc29659ac47999cf3ee2d9cd34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a7a2479fc29659ac47999cf3ee2d9cd34">primeCountUndirected</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, unsigned long length, std::vector&lt; int &gt; &amp;subgraph, unsigned long neighboursNumber, std::vector&lt; double &gt; &amp;primes)</td></tr>
<tr class="separator:a7a2479fc29659ac47999cf3ee2d9cd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e58549a488fbf640ae33517cc8583c8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a3e58549a488fbf640ae33517cc8583c8">primeCountDirected</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, unsigned long length, std::vector&lt; int &gt; &amp;subgraph, unsigned long neighboursNumber, std::vector&lt; double &gt; &amp;primes)</td></tr>
<tr class="separator:a3e58549a488fbf640ae33517cc8583c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e094118546211841d303c85eb6a060f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a5e094118546211841d303c85eb6a060f">cycleCountFixedVertex</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, int vertex, unsigned long length)</td></tr>
<tr class="separator:a5e094118546211841d303c85eb6a060f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cadb51183f7418039b7a59e0e1c291"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#ae7cadb51183f7418039b7a59e0e1c291">recursiveSubgraphsFixedVertex</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, int vertex, unsigned long length, std::vector&lt; int &gt; subgraph, std::vector&lt; bool &gt; allowedVertex, std::vector&lt; double &gt; primes, std::vector&lt; bool &gt; neighbourhood)</td></tr>
<tr class="separator:ae7cadb51183f7418039b7a59e0e1c291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819a196414e39c1fdd42ed46e1464254"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a819a196414e39c1fdd42ed46e1464254">primeCountFixedVertex</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, int vertex, unsigned long length, std::vector&lt; int &gt; &amp;subgraph, unsigned long neighboursNumber, std::vector&lt; double &gt; &amp;primes)</td></tr>
<tr class="separator:a819a196414e39c1fdd42ed46e1464254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cd55a9ba136e0e3d43fbdf5981c00c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a21cd55a9ba136e0e3d43fbdf5981c00c">subgraphAdjacencyMatrix</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, const std::vector&lt; int &gt; &amp;subgraph)</td></tr>
<tr class="separator:a21cd55a9ba136e0e3d43fbdf5981c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2e62abcc77f13c0aa3f673e1866cd5"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a3e2e62abcc77f13c0aa3f673e1866cd5">subgraphAdjacencyArray</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, const std::vector&lt; int &gt; &amp;subgraph)</td></tr>
<tr class="separator:a3e2e62abcc77f13c0aa3f673e1866cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca0046271d64973dba4093a67e1a904"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#acca0046271d64973dba4093a67e1a904">restrictedAdjacencyMatrix</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;adjacencyMatrix, const std::vector&lt; int &gt; &amp;subgraph)</td></tr>
<tr class="separator:acca0046271d64973dba4093a67e1a904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c6071ae7355b9d5ae82a9461b9e4fa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#ac0c6071ae7355b9d5ae82a9461b9e4fa">matrixMultiplication</a> (const double x, const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;M)</td></tr>
<tr class="separator:ac0c6071ae7355b9d5ae82a9461b9e4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306d34e1fb4ab46e0f1f3d5e79e623f0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a306d34e1fb4ab46e0f1f3d5e79e623f0">matrixAddition</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;A, const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;B)</td></tr>
<tr class="separator:a306d34e1fb4ab46e0f1f3d5e79e623f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443d120ecd6af9b8ab0e9b50c62a613b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a443d120ecd6af9b8ab0e9b50c62a613b">squareMatrixMultiplication</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;A, const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;B)</td></tr>
<tr class="separator:a443d120ecd6af9b8ab0e9b50c62a613b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa5e7bd4c12cb039d70db079da20419"><td class="memItemLeft" align="right" valign="top">long unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#aeaa5e7bd4c12cb039d70db079da20419">countTrue</a> (const std::vector&lt; bool &gt; &amp;vector)</td></tr>
<tr class="separator:aeaa5e7bd4c12cb039d70db079da20419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad287a1a966f84740207a7eb031197c46"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#ad287a1a966f84740207a7eb031197c46">sum</a> (double *array, long unsigned n)</td></tr>
<tr class="separator:ad287a1a966f84740207a7eb031197c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c14e3f2db91f2b8f45b47c9a6d757a0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cycle_count_8cpp.html#a5c14e3f2db91f2b8f45b47c9a6d757a0">trace</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;M)</td></tr>
<tr class="separator:a5c14e3f2db91f2b8f45b47c9a6d757a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6dabfa59d44c075887cbe5466ed7030f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dabfa59d44c075887cbe5466ed7030f">&#9670;&nbsp;</a></span>EIGEN_MAX_ITERATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EIGEN_MAX_ITERATION&#160;&#160;&#160;10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00010">10</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aeaa5e7bd4c12cb039d70db079da20419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa5e7bd4c12cb039d70db079da20419">&#9670;&nbsp;</a></span>countTrue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned countTrue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count number of true entry in a vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>the boolean vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true values counter </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00724">724</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a26ca4ca2fc0aa3db96311d853c95c825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ca4ca2fc0aa3db96311d853c95c825">&#9670;&nbsp;</a></span>cycleCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; cycleCount </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts all simple cycle of length up to length included on adjacencyMatrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>Undirected adjacency matrix of the graph G, this matrix may be weighted. </td></tr>
    <tr><td class="paramname">length</td><td>maximum length of the simple cyles to be counted </td></tr>
    <tr><td class="paramname">directed</td><td>true if the graph is directed, false if not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array whose entry i is the number of simple cycles of length i in the graph </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Originally designed by P.-L. Giscard, N. Kriege, R. C. Wilson, July 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00202">202</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a5e094118546211841d303c85eb6a060f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e094118546211841d303c85eb6a060f">&#9670;&nbsp;</a></span>cycleCountFixedVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; cycleCountFixedVertex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts all simple cycle of length up to length passing through a specified vertex </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>Undirected adjacency matrix of the graph G, this matrix may be weighted. </td></tr>
    <tr><td class="paramname">vertex</td><td>the fixed vertex index </td></tr>
    <tr><td class="paramname">length</td><td>maximum length of the simple cycles to be counted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array whose entry i is the number of simple cycles of length i passing through the fixed vertex </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Originally designed by P.-L. Giscard, N. Kriege, R. C. Wilson, July 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00445">445</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a306d34e1fb4ab46e0f1f3d5e79e623f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306d34e1fb4ab46e0f1f3d5e79e623f0">&#9670;&nbsp;</a></span>matrixAddition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; matrixAddition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first square matrix </td></tr>
    <tr><td class="paramname">B</td><td>second square matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix (A + B) </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00686">686</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="ac0c6071ae7355b9d5ae82a9461b9e4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c6071ae7355b9d5ae82a9461b9e4fa">&#9670;&nbsp;</a></span>matrixMultiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; matrixMultiplication </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>double value for multiplication </td></tr>
    <tr><td class="paramname">M</td><td>square matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix (x * M) </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00667">667</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a917f856829fd502d3c445095d53a82ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917f856829fd502d3c445095d53a82ea">&#9670;&nbsp;</a></span>pathsCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;double&gt; &gt; &gt; pathsCount </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts all simple paths and cycles of length up to length included on adjacencyMatrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>Undirected adjacency matrix of the graph G, this matrix may be weighted. </td></tr>
    <tr><td class="paramname">length</td><td>maximum length of the simple path to be counted </td></tr>
    <tr><td class="paramname">directed</td><td>true if the graph is directed, false if not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array whose entry [i][x][y] is the number of simple paths of length i from x to yin the graph </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Originally designed by P.-L. Giscard, N. Kriege, R. C. Wilson, July 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00021">21</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a6356a2ac3c7689b35ac0f7b47d7f1b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6356a2ac3c7689b35ac0f7b47d7f1b4b">&#9670;&nbsp;</a></span>primeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; primeCount </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>neighboursNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple handler to split between directed and undirected function calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>adjacency matrix of the graph, must be symmetric </td></tr>
    <tr><td class="paramname">length</td><td>maximum subgraph size, an integer </td></tr>
    <tr><td class="paramname">subgraph</td><td>current subgraph, a list of vertices, further vertices are added to this list </td></tr>
    <tr><td class="paramname">neighboursNumber</td><td>number of neighbours from the induced subgraph to the graph </td></tr>
    <tr><td class="paramname">primes</td><td>current cycles count array </td></tr>
    <tr><td class="paramname">directed</td><td>true if the graph is directed, false if not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated cycles count array </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Originally designed by P.-L. Giscard, N. Kriege, R. C. Wilson, July 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00318">318</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a3e58549a488fbf640ae33517cc8583c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e58549a488fbf640ae33517cc8583c8">&#9670;&nbsp;</a></span>primeCountDirected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; primeCountDirected </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>neighboursNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>primes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the contribution to the combinatorial sieve of a given subgraph. This function is an implementation of the equation extracting prime numbers from connected induced subgraphs. do not use externally, use primeCount(_, true) instead </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>adjacency matrix of the graph, must be symmetric </td></tr>
    <tr><td class="paramname">length</td><td>maximum subgraph size, an integer </td></tr>
    <tr><td class="paramname">subgraph</td><td>current subgraph, a list of vertices, further vertices are added to this list </td></tr>
    <tr><td class="paramname">neighboursNumber</td><td>number of neighbours from the induced subgraph to the graph </td></tr>
    <tr><td class="paramname">primes</td><td>current cycles count array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated cycles count array </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Originally designed by P.-L. Giscard, N. Kriege, R. C. Wilson, July 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00400">400</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a819a196414e39c1fdd42ed46e1464254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819a196414e39c1fdd42ed46e1464254">&#9670;&nbsp;</a></span>primeCountFixedVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; primeCountFixedVertex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>neighboursNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>primes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the contribution to the combinatorial sieve of a given subgraph. This function is an implementation of the equation extracting prime numbers from connected induced subgraphs for a fixed vertex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>adjacency matrix of the graph </td></tr>
    <tr><td class="paramname">length</td><td>maximum subgraph size, an integer </td></tr>
    <tr><td class="paramname">vertex</td><td>the fixed vertex </td></tr>
    <tr><td class="paramname">subgraph</td><td>current subgraph, a list of vertices, further vertices are added to this list </td></tr>
    <tr><td class="paramname">neighboursNumber</td><td>number of neighbours from the induced subgraph to the graph </td></tr>
    <tr><td class="paramname">primes</td><td>current cycles count array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated cycles count array </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Originally designed by P.-L. Giscard, N. Kriege, R. C. Wilson, July 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00557">557</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a39473983d87ddb4bb00bf72cc3c49c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39473983d87ddb4bb00bf72cc3c49c6d">&#9670;&nbsp;</a></span>primeCountPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;double&gt; &gt; &gt; primeCountPath </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>neighboursNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>primes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the contribution to the combinatorial sieve of a given subgraph. This function is an implementation of the equation extracting prime numbers from connected induced subgraphs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>adjacency matrix of the graph, must be symmetric </td></tr>
    <tr><td class="paramname">length</td><td>maximum subgraph size, an integer </td></tr>
    <tr><td class="paramname">subgraph</td><td>current subgraph, a list of vertices, further vertices are added to this list </td></tr>
    <tr><td class="paramname">neighboursNumber</td><td>number of neighbours from the induced subgraph to the graph </td></tr>
    <tr><td class="paramname">primes</td><td>current paths count array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated paths count array </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Originally designed by P.-L. Giscard, N. Kriege, R. C. Wilson, July 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00144">144</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a7a2479fc29659ac47999cf3ee2d9cd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2479fc29659ac47999cf3ee2d9cd34">&#9670;&nbsp;</a></span>primeCountUndirected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; primeCountUndirected </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>neighboursNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>primes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the contribution to the combinatorial sieve of a given subgraph. This function is an implementation of the equation extracting prime numbers from connected induced subgraphs. It use eigenvalues to compute trace to the power recursively. do not use externally, use primeCount(_, false) instead </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>adjacency matrix of the graph, must be symmetric </td></tr>
    <tr><td class="paramname">length</td><td>maximum subgraph size, an integer </td></tr>
    <tr><td class="paramname">subgraph</td><td>current subgraph, a list of vertices, further vertices are added to this list </td></tr>
    <tr><td class="paramname">neighboursNumber</td><td>number of neighbours from the induced subgraph to the graph </td></tr>
    <tr><td class="paramname">primes</td><td>current cycles count array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated cycles count array </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Originally designed by P.-L. Giscard, N. Kriege, R. C. Wilson, July 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00345">345</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a84eabb4f4c460f175ec21b366b5efd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84eabb4f4c460f175ec21b366b5efd63">&#9670;&nbsp;</a></span>recursiveSubgraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; recursiveSubgraphs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>allowedVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>neighbourhood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all the connected induced subgraphs of size up "length" of a graph known through its adjacency matrix "A" and containing the subgraph "Subgraph" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>adjacency matrix of the graph, preferably sparse </td></tr>
    <tr><td class="paramname">length</td><td>maximum subgraph size, an integer </td></tr>
    <tr><td class="paramname">subgraph</td><td>current subgraph, a list of vertices, further vertices are added to this list </td></tr>
    <tr><td class="paramname">allowedVertex</td><td>indicator vector of pruned vertices that may be considered for addition to the current subgraph to form a larger one </td></tr>
    <tr><td class="paramname">primes</td><td>list regrouping the contribution of all the subgraphs found so far </td></tr>
    <tr><td class="paramname">neighbourhood</td><td>indicator vector of the vertices that are contained in the current subgraph or reachable via one edge </td></tr>
    <tr><td class="paramname">directed</td><td>true if the graph is directed, false if not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>primes with one more subgraph </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Originally designed by P.-L. Giscard, N. Kriege, R. C. Wilson, July 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00261">261</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="ae7cadb51183f7418039b7a59e0e1c291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cadb51183f7418039b7a59e0e1c291">&#9670;&nbsp;</a></span>recursiveSubgraphsFixedVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; recursiveSubgraphsFixedVertex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>allowedVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>neighbourhood</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all the connected induced subgraphs of size up "length" of a graph known through its adjacency matrix "A" and containing the subgraph "Subgraph" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>adjacency matrix of the graph, must be symmetric </td></tr>
    <tr><td class="paramname">vertex</td><td>the fixed vertex index </td></tr>
    <tr><td class="paramname">length</td><td>maximum subgraph size, an integer </td></tr>
    <tr><td class="paramname">subgraph</td><td>current subgraph, a list of vertices, further vertices are added to this list </td></tr>
    <tr><td class="paramname">allowedVertex</td><td>indicator vector of pruned vertices that may be considered for addition to the current subgraph to form a larger one </td></tr>
    <tr><td class="paramname">primes</td><td>list regrouping the contribution of all the subgraphs found so far </td></tr>
    <tr><td class="paramname">neighbourhood</td><td>indicator vector of the vertices that are contained in the current subgraph or reachable via one edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated cycles count list </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Originally designed by P.-L. Giscard, N. Kriege, R. C. Wilson, July 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00500">500</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="ad27cf7494f9faa660df78fbd19af5cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27cf7494f9faa660df78fbd19af5cb3">&#9670;&nbsp;</a></span>recursiveSubgraphsPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;double&gt; &gt; &gt; recursiveSubgraphsPaths </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>allowedVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>primes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>neighbourhood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all the connected induced subgraphs of size up "length" of a graph known through its adjacency matrix "A" and containing the subgraph "Subgraph" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>adjacency matrix of the graph, preferably sparse </td></tr>
    <tr><td class="paramname">length</td><td>maximum subgraph size, an integer </td></tr>
    <tr><td class="paramname">subgraph</td><td>current subgraph, a list of vertices, further vertices are added to this list </td></tr>
    <tr><td class="paramname">allowedVertex</td><td>indicator vector of pruned vertices that may be considered for addition to the current subgraph to form a larger one </td></tr>
    <tr><td class="paramname">primes</td><td>list regrouping the contribution of all the subgraphs found so far </td></tr>
    <tr><td class="paramname">neighbourhood</td><td>indicator vector of the vertices that are contained in the current subgraph or reachable via one edge </td></tr>
    <tr><td class="paramname">directed</td><td>true if the graph is directed, false if not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>primes with one more subgraph </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Originally designed by P.-L. Giscard, N. Kriege, R. C. Wilson, July 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00083">83</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="acca0046271d64973dba4093a67e1a904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca0046271d64973dba4093a67e1a904">&#9670;&nbsp;</a></span>restrictedAdjacencyMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; restrictedAdjacencyMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The adjacency matrix restricted to subgraph </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>the original adjacency matrix </td></tr>
    <tr><td class="paramname">subgraph</td><td>list of vertexes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>adjacencyMatrix with (entry[i][j] = 0) if i or j not in subgraph </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00645">645</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a443d120ecd6af9b8ab0e9b50c62a613b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443d120ecd6af9b8ab0e9b50c62a613b">&#9670;&nbsp;</a></span>squareMatrixMultiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; squareMatrixMultiplication </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first square matrix </td></tr>
    <tr><td class="paramname">B</td><td>second square matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix (A * B) </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00704">704</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a3e2e62abcc77f13c0aa3f673e1866cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2e62abcc77f13c0aa3f673e1866cd5">&#9670;&nbsp;</a></span>subgraphAdjacencyArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* subgraphAdjacencyArray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a flatten adjacency matrix induced by a vertex list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>original adjacency matrix </td></tr>
    <tr><td class="paramname">subgraph</td><td>list of index for the induced adjacency matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the adjacency matrix with only specified indexes </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00624">624</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a21cd55a9ba136e0e3d43fbdf5981c00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cd55a9ba136e0e3d43fbdf5981c00c">&#9670;&nbsp;</a></span>subgraphAdjacencyMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; subgraphAdjacencyMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacencyMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the adjacency matrix induced by a vertex list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacencyMatrix</td><td>original adjacency matrix </td></tr>
    <tr><td class="paramname">subgraph</td><td>list of index for the induced adjacency matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the adjacency matrix with only specified indexes </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00600">600</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="ad287a1a966f84740207a7eb031197c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad287a1a966f84740207a7eb031197c46">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double sum </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>an array of double </td></tr>
    <tr><td class="paramname">n</td><td>an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the n first values of array </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00739">739</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
<a id="a5c14e3f2db91f2b8f45b47c9a6d757a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c14e3f2db91f2b8f45b47c9a6d757a0">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double trace </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>an array of double </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trace of the matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="cycle_count_8cpp_source.html#l00751">751</a> of file <a class="el" href="cycle_count_8cpp_source.html">cycleCount.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="cycle_count_8cpp.html">cycleCount.cpp</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
